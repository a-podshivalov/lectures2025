# Практические задания 1: без радио

## Необходимая документация

Описание нужных модулей Riot можно посмотреть в официальной документации, например:

Управление процессами: https://doc.riot-os.org/group__core.html
Управление GPIO: https://doc.riot-os.org/group__drivers__periph__gpio.html
Таймеры: https://doc.riot-os.org/group__sys__xtimer.html

Обратите внимание, что обработчики прерываний GPIO и callback-функции таймеров выполняются в контексте прерываний - если вы обращаетесь к одним и тем же переменным из основного потока и из прерывания, возможны ситуации, когда чтение или запись будут выполнены некорректно. Используйте, например, имеющиеся в Riot средства для атомарного доступа к памяти: https://doc.riot-os.org/group__sys__atomic__utils.html

Для подключения этих модулей в Makefile надо добавить строки
```
USEMODULE += periph_gpio # для работы с GPIO
USEMODULE += periph_gpio_irq # поддержка прерываний от GPIO
USEMODULE += xtimer
USEMODULE += atomic_utils # атомарный доступ к памяти
```

Для работы с внешними устройствами можно использовать имеющиеся в комплекте оборудования модули с датчиками освещенности OPT3001 (UMDK-LIT), температуры-влажности-давления BME280 (UMDK-THP), акселерометром/гироскопом LSM6DS3 (UMDK-ACC). Все они подключены по интерфейсу I2C, примеры работы с этими датчиками есть на Github (`examples-miem/sensors`).

Принципиальные схемы элементов "конструктора" Unwired Devices выложены здесь: https://github.com/unwireddevices/umdk-boards

## Критерии сдачи заданий

Цифры после номеров заданий обозначают сложность в "баллах", баллы за их выполнение суммируются "с накоплением", всего за работу на практических занятиях можно набрать 10 баллов. Всего будет два "пакета" заданий; общая сумма баллов существенно больше 10, поэтому если чувствуете уверенность в своих силах - попробуйте начать с более сложных, это как минимум будет более интересно. Все задания делать необязательно.

Каждое из заданий сдается индивидуально, необходимо предъявить преподавателю репозиторий в МИЭМовском Gitlab (https://git.miem.hse.ru) с кодом программы (удобнее всего создать копию репозитория Riot, а внутри него - отдельный каталог для своих проектов) и продемонстрировать его работоспособность на "железе". Задания можно выполнять как с использованием "конструктора" Unwired Devices, так и с любыми другими отладочными платами, поддерживающимися в ОС Riot.

Если какое-то из задания "сдано" больше, чем 1/2 группы - то со следующего занятия оно принимается с понижающим коэффициентом 1/2 (то есть за него начисляется лишь половина баллов).

## Задания

Задания с 1 по 5 выполняются с применением только GPIO и таймеров, дополнительные процессы создавать не надо. Если вам этих возможностей не хватает - подумайте, может быть, надо делать проще! Задания принимаются до 14.04.2025.

1. (1) Лампочка с выключателем - для любой платы с хотя бы одной кнопкой и светодиодом. Напишите программу, которая по нажатию кнопки включала и выключала бы светодиод:
    1. с использованием периодического опроса кнопок в цикле;
    2. обрабатывая нажатие кнопки в прерывании с обработкой "дребезга" путем отключения прерываний;
    3. светодиод должен не просто включаться, а мигать с заданной частотой, длинное нажатие кнопки переключает частоту миганий.

2. (1) Кодовый замок - подключите несколько кнопок (или плату UMDK-4BTN с четырьмя кнопками), напишите программу, которая при нажатии кнопок в правильном порядке ("наборе кода") зажигала бы светодиод на плате, а при повторном наборе - гасила бы его. Добавьте вывод в консоль сообщений о неправильных попытках ввода кода и тому подобных ситуациях. Логика работы - по вашему усмотрению. Посмотреть, каким выводам микроконтроллера соответствуют штыревые выводы на плате отладчика, можно в файле `boards/unwd-range-l1-r3/board.h`.

3. (1) Светофор с кнопкой - подключите к микроконтроллеру несколько светодиодов (в лаборатории есть макетные платы и разнообразное дополнительное оборудование), переключайте их по заданной программе; при нажатии кнопки проверьте, сколько осталось до очередного включения "зеленого света" на нужном направлении, и если это время больше нужного - запланируйте новое переключение; если же зеленый свет и так скоро включится - то ничего не делайте (как на переходе между станцией метро "Строгино" и зданием МИЭМа). (1) Подключите к микроконтроллеру символьный ЖК-дисплей и выводите на нем оставшееся до переключения время.

4. Реализуйте кодирование (1) и декодирование (2) кода Морзе с использованием GPIO микроконтроллера.

5. (2) Фирма ST Microelectronics заявляет, что в стоящем на наших платах микроконтроллере (STM32L151) имеется high-performance ARM core, и даже приводит циферки, которые он набирает в бенчмарках. Проверьте это, скомпилировав любой из популярных бенчмарков, как приложение под RIOT. Сравните это с результатами того же бенчмарка на своем компьютере.
    1. Coremark (93 Coremark). Не вносите изменения в файлы самого бенчмарка, за исключением `core_portme.c` и `core_portme.h`.
    2. Dhrystone (33 DMIPS). Учтите, что Dhrystone необходимо собирать с отключенными оптимизациями компилятора, а сам код бенчмарка написан в очень устаревшем стиле, в современных компиляторах приводящем к генерации массы предупреждений (warning). Изучите Makefile-ы операционной системы, посмотрите, как можно подавить эти предупреждения или отключить их. Кроме того, понадобится включить печать float-ов в `printf()`, добавив в флаги компоновщика (линкера) опцию `-u _printf_float`.

6. (1) Проверьте, в каких областях памяти создаются глобальные и локальные переменные у разных процессов, обработчиков прерываний и т. п., как влияют на расположение переменных в памяти модификаторы `const` и `static`. Для этого создайте несколько таких переменных, а потом выведите в `printf` их адреса, например, так (аналогичным образом можно выводить адреса функций):
```
static const int i;
printf("Static const local to main() is at %p\n", &i);
```

7. (1) Продемонстрируйте в RIOT инверсию приоритетов (в том числе с участием "среднеприоритетного" процесса, не конкурирующего за ресурс - посмотрите в качестве примера `tests/thread_priority_inversion`) и взаимоблокировку потоков. Включите опцию "наследования приоритета" при захвате mutex-а, убедитесь, что она работает. Какие недостатки имеет это решение?

8. (1) Подключите одновременно датчики температуры-влажности-давления BME280 и DHT11, сравните их показания.

9. (2) Метеостанция с LCD-дисплеем: выведите показания датчика BME280 или DHT11 на ЖК-дисплей, подключенный к микроконтроллеру.

10. (2) Реализуйте датчик удара/перемещения с использованием акселерометра (например, при ударе или перемещении устройства зажигайте светодиод).

11. (2) Таймер с датчиком приближения: подключите к микроконтроллеру любой датчик "приближения" (инфракрасный или ультразвуковой), при срабатывании датчика включайте "исполнительный механизм" на заданное время (например, 20 секунд) - представьте, например, что вы управляете рукомойником с бесконтактным датчиком.

12. (2) Включите в приложение модуль shell (`sys/shell`), добавьте несколько собственных команд, например, для получения данных от датчиков.

13. (2) Выведите адреса (можно ограничиться 7-битными) всех устройств, подключенных по шине I2C.

14. (2) Добавьте опрос нескольких датчиков, получение данных от них, управление GPIO и тому подобное - на ваш выбор - по протоколу Modbus RTU, используя штатный ("консольный") UART. Для проверки работы Modbus будет использоваться программа Termite: http://s2-team.ru/termite-quick-start-guide/

15. (1) Используя рекомендации фирмы Maxim (https://www.maximintegrated.com/en/design/technical-documents/tutorials/2/214.html) и драйвер 1-wire (`drivers/onewire`), подключите к микроконтроллеру устройство с интерфейсом 1-Wire (например, "домофонный" ключ).

16. (2) Ночник: с помощью ШИМ регулируйте яркость светодиода в зависимости от показаний датчика освещенности.

17. (2) Кодовый замок-2: Добавьте к кодовому замку из первого набора заданий модуль чтения бесконтактных карт (он прекрасно работает с "Тройкой", читая ее идентификатор). Картам авторизованных пользователей должны соответствовать индивидуальные пароли, замок должен открываться только после прочтения карты и набора правильного пароля.

18. (2-4) Добавьте драйвер любого внешнего устройства, которого еще нет в RIOT.

19. (3) С помощью bit-banging реализуйте однопроводную "шину" для связи между несколькими устройствами. Можно использовать, например, UART-подобный протокол, для подключения нескольких устройств используйте выход с открытым коллектором. (2) Оформите программный интерфейс `netif` для этой шины.

20. (2) В операционной системе mbed неоптимальным с точки зрения энергопотребления образом реализован переход микроконтроллеров семейства STM32L1 в спящий режим (частично проблема описана тут: https://habr.com/ru/articles/420435/). Исправьте. (10) Добейтесь принятия ваших изменений в upstream.